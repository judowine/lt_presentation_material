# 2. 宣言的UIとは何か？：UIは「ステート」に駆動される

さて、今日の主役の一つである「宣言的UI」とは一体何なのでしょうか？

従来のモバイルアプリ開発、例えばAndroidのXMLやiOSのUIKitを使った「命令的UI」では、UIの状態を変更する際に、私たちはコードで「UIをどう操作するか」という手順を、命令形で記述していました。例えば、

> ユーザーがボタンをタップしたら、TextViewのテキストをsetText("新しい値")で更新しなさい！

といった具合です。UIの状態が変わるたびに、開発者が具体的なUIコンポーネントを探し出し、そのプロパティを直接変更する命令を与える必要があったのです。

---

## UIの「状態」を宣言する

これに対し、Jetpack ComposeやSwiftUIのような宣言的UIでは、私たちはUIコンポーネントの「状態（どうあるべきか）」を宣言的に記述します。つまり、

> ここに"Count: 0"というテキストが表示されていて、その下にボタンがある

というように、その瞬間のUIがどのような状態であるべきかをコードで「宣言」するのです。

最も重要な違いは、UIの更新方法にあります。命令的UIではデータが変わるたびに開発者が手動でUIを操作する必要がありましたが、宣言的UIでは、UIの元となるデータ（ステート）が変われば、UIが自動的に再描画される仕組みになっています。私たちは「UIをどう更新するか」という手順ではなく、「あるデータ（ステート）ならば、UIはこうあるべき」という理想の姿を定義するだけです。

---

## UIを「ステート」で駆動する

この「データが変わればUIが自動的に再描画される」という仕組みこそが、UIが「ステート駆動」であることの本質です。

具体例を見てみましょう。皆さんおなじみのカウンターアプリです。

```kotlin
@Composable
fun CounterScreen() {
    // この `count` が、このUIの「ステート（状態）」です。
    // UIの表示内容を直接決定するデータです。
    var count by remember { mutableStateOf(0) } // UIのステート

    Column {
        // `count` の値に基づいてUI（テキスト）が表示されます。
        // countが変われば、このTextコンポーザブルが自動的に再描画されます。
        Text(text = "Count: $count") 

        // ボタンがクリックされる「イベント」が発生すると...
        Button(onClick = { 
            // `count` というUIのステートが変更されます。
            count++ 
        }) {
            Text("Increment") 
        }
    }
}
```

この例では、`count` という変数がUIのステート（状態）です。ボタンがタップされるというイベントが発生すると、`count` というステートが変更されます。するとフレームワークがその変更を検知し、自動的に画面上の数字（UI）が更新されるのです。

このように、UIの表示はUIのステートに「駆動」されています。開発者は「ボタンがクリックされたらUIを更新せよ」と命令するのではなく、「countというステートがこういう値なら、UIはこうあるべきだ」と宣言するだけで済むのです。

---

このシンプルさが、宣言的UIの強力な点であり、同時にテスタビリティを考える上で非常に重要な出発点となります。