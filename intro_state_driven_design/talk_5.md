# 5. テスタビリティを損なう「副作用」の管理

さて、私たちはここまで、UIを「ステート」で駆動し、そのステートをUIから分離した「UI State Holder」や、さらにその奥にある「ドメインステート」として管理していくことの重要性を見てきました。これによって、ロジックとUIを独立させてテストできる、というメリットをお伝えしましたね。

しかし、宣言的UIが持つテスタビリティの恩恵を壊してしまう、大きな落とし穴があります。それが「副作用（Side Effect）」です。

---

## 副作用とは何か？

プログラミングにおける副作用とは、「関数や処理が、その結果として返す値以外に、外部の状態を変化させること」を指します。

例えば、どんなものが副作用にあたるでしょうか？

- ネットワーク通信：サーバーからデータを取得したり、送ったり。
- データベースへの書き込み：ローカルにデータを保存したり、読み込んだり。
- ファイルの読み書き：設定ファイルなどを操作する。
- ログの出力：コンソールにメッセージを出す。
- タイマーの開始/停止：時間に関する処理。

これらは、アプリが実際に動く上で避けられない、非常に重要な処理ばかりです。

---

## 宣言的UIの「副作用」の落とし穴

宣言的UIでは、UIはステートに基づいて「表示する」ことに特化すべきです。しかし、時に宣言的UIの実装内に、ステートを変更する処理や、UIを表示する処理以外の「副作用」を直接書いてしまうことがあります。これが、ステート駆動と宣言的UIが持つテスタビリティを壊してしまう大きな落とし穴になるんです。

具体例を見てみましょう。先ほどのカウンターアプリで、ボタンをクリックするたびに、そのカウント値をサーバーに保存するようなケースを想像してください。

```kotlin
@Composable
fun BadExampleScreen() {
    var count by remember { mutableStateOf(0) }
    
    Button(onClick = { 
        count++ 
        // 🚨 良くない例：宣言的UIの中に直接ネットワーク通信！
        // APIを呼び出してデータを保存する処理
        saveCountToServer(count) 
    }) {
        Text("Increment and Save")
    }
    // ...
}
```

このようなコードは、以下のような深刻な問題を引き起こします。

- **テストの困難性**: BadExampleScreenのテストをするには、毎回ネットワーク環境を整える必要があります。テストが遅くなり、安定しなくなります。特定のcountの状態でUIがどうなるか、といったUIの表示だけのテストも難しくなります。
- **関心の分離の欠如**: UIの表示ロジックの中に、ビジネスロジック（データの保存）や、外部との通信といった関心が混在してしまいます。結果として、コードの可読性やメンテナンス性が著しく低下します。
- **予期せぬ再実行**: 宣言的UIはステートの変化に応じてUIコンポーネントを再実行（リコンポーズ/リフレッシュ）します。副作用を直接書くと、意図しないタイミングでAPIが何度も呼ばれてしまう、といった予期せぬ動作に繋がる可能性があります。

---

## 副作用の理想的な管理：Callbackによる責務の摘出とMVI

では、どうすれば良いのでしょうか？
ステート駆動アーキテクチャの目標は、「副作用を特定の場所に集約し、それ以外のロジックは副作用を持たない純粋な関数として扱う」ことです。

その鍵となるのが、Callback（コールバック）として副作用の処理を宣言的UIの外に切り出すというアプローチです。これにより、宣言的UIから副作用の**「実行」という責務自体を完全に摘出**することができます。

このCallbackによる責務の切り出し、そしてUIの状態管理とイベント処理を明確に分離する考え方は、Androidアプリのデザインパターンとして近年台頭している「MVI（Model-View-Intent）」パターンと非常に親和性が高いです。MVIは、UIからの「意図（Intent）」を受け取り、状態（Model）を更新し、その状態をUI（View）に反映するという、厳格な単方向データフローと副作用管理を特徴としています。まさに、宣言的UIのテスタビリティを最大限に引き出すためのアーキテクチャと言えるでしょう。

---

## 理想的な流れ

1. **イベント発生 (ユーザーのボタンタップなど)**
2. **UIがイベントをCallbackとして通知**: UIは直接副作用を実行せず、単に「ボタンが押されたよ」というイベントを、Callbackを通じてアプリのステートを管理する層（ViewModelなど）に伝えます。このCallback自体は副作用を持ちません。
3. **アプリのステート変更ロジック (副作用なし)**: イベントを受け取ったステート管理層は、ドメインモデルを含むアプリのステートをどのように変化させるかを計算します。ここではネットワーク通信やDB操作は行いません。純粋な計算処理です。
4. **副作用の実行 (特定の場所)**: アプリのステート管理層が、ビジネスロジックで計算された結果、もしネットワーク通信などが必要なら、責任を持った特定の場所（例えば、UseCaseやRepositoryといった層）に依頼し、実行させます。
5. **UIの更新 (副作用なし)**: 副作用の実行結果（成功・失敗など）は、アプリのステートに反映されます。そして、変更されたアプリのステートとUIのステートに基づいて、画面が再描画されます。ここも原則として副作用を持ちません。

---

このように、宣言的UIは「状態を受け取って表示する」ことと、「イベントをCallbackで通知する」ことに徹底的に専念します。副作用をCallbackとして切り出し、UIの外部にある特定の責任を持つ層で管理することで、UI層はビジネスロジックや外部依存から完全に独立してテスト可能になります。結果として、宣言的UIが持つテスタビリティの恩恵を最大限に引き出すことができるのです。